{"version":3,"sources":["components/LazyLoadingComponent/LazyLoadingComponent.jsx","components/App/App.jsx","components/LazyLoadingComponent/FadeInComponent.jsx","components/TestComponents/Component1/Component1.jsx","components lazy /^/.//.*$/ groupOptions: {} namespace object","serviceWorker.js","index.js"],"names":["LazyLoadingComponent","idElementActivation","idElementForNextLazyLoading","pathComponent","fadeInEffect","debugMode","useState","ComponentToLoad","setComponentToLoad","initComponent","_","target","targetElement","document","getElementById","IntersectionObserver","entries","observer","console","log","forEach","entry","isIntersecting","then","res","a","ComponentLazyLoaded","default","splitPathComponentToLoad","split","length","disconnect","observe","useEffect","className","id","App","FadeInComponent","children","map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","e","Error","code","ids","all","slice","t","keys","Object","module","exports","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f098ad34.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react'\n// import FadeInComponent to apply to the component that we wanna lazy load a fadeIn effect (optional)\nimport FadeInComponent from './FadeInComponent'\nimport './LazyLoadingComponent.css'\n\n/**\n *  ***********************WARNING**************************\n *  Before using this component there are a couple things you need to know:\n *  1) The dinamic import must have a relative path specified. LazyLoadingComponent has a static path specified inside the dinamic import ==> '../', so keep in mind when you'll use it\n *      Example: path LazyLoadingComponent.jsx: src > components > LazyLoadingComponent > LazyLoadingComponent.jsx\n *               path App.jsx (the 'alpha' component): src > components > App > App.jsx\n *               path MYCOMPONENT.jsx: src > components > manyComponentsFolder > MYCOMPONENT > MYCOMPONENT.jsx\n *               path_MYCOMPONENT_to_pass_as_argument_to_LazyLoadingComponent: 'manyComponentsFolder/MYCOMPONENT/MYCOMPONENT' (I didn't leave nothing behind)\n *  \n *  2) This component cannot be used to lazy load the first component of the page (there are no components before it)\n *  3) If this component is used only to load the second component of the page, the lazy loading will the same as using React.lazy loading inside the page where you're calling LazyLoadingComponent\n *  4) To use all this component's power, I recommend you to leave every div with 'lazy-load-component' class having (padding: 50px 0;)\n *  5) It's still a work in progress so, I'll try to find new solutions and ANY HELP IT'S APPRECIATED ;)\n */\n\n/**\n * \n *  @param idElementActivation ==> the id of the component that will cause the dynamic loading of the component whose path was passed as parameter if the user's view will encouter the section containing that id\n *  @param idElementForNextLazyLoading ==> the id that the next LazyLoadingComponent will check with the IntersectionObserver to understand when dinamically load the component whose path was passed as argument\n *  @param pathComponent ==> relative path of the component to load\n *  @param fadeInEffect ==> fadeIn class listed in animate.css file (https://daneden.github.io/animate.css/) or (https://github.com/daneden/animate.css)\n *  @param debugMode ==> if its value is true, then it will show some console.log message to help the developer understand what's happening. Otherwise it won't show anything.\n * \n *  LazyLoadingComponent goal's is to allow the user to lazy loading the component\n *  which relative path is passed by argument with an optional fadeIn effect from animate.css\n */\nconst LazyLoadingComponent = ({ idElementActivation = \"\", idElementForNextLazyLoading = \"\", pathComponent = \"\", fadeInEffect = \"undefined\", debugMode = \"false\" }) => {\n    // ComponentToLoad (is the state of the component)\n    // ComponentToLoad final's value will be the component to load inside the FadeInComponent\n    // Example: ComponentToLoad ==> <FadeInComponent><MYCOMPONENTLAZYLOADED/></FadeInComponent>\n    const [ComponentToLoad, setComponentToLoad] = useState(null)\n\n    // lazyLoading function will check if the element with the id (idElementActivation) has already intersected the screen\n    // and if yes, then the component with path (pathComponent) will be dinamically loaded and returned inside the FadeInComponent\n    // which will apply the animation if it was passed by argument (fadeInEffect)\n    const lazyLoading = target => {\n        const io = new IntersectionObserver((entries, observer) => {\n            if (debugMode === \"true\") {\n                console.log(`intersection observer activated for component having idElementForNextLazyLoading ==> ${idElementForNextLazyLoading}`)\n            }\n            // for each entry the code verifies with isIntersecting if the user's view\n            // is already been intersecting with the component having id (idElementActivation)\n            entries.forEach(entry => {\n                // if the component with id = idElementActivation intersect the user's view,\n                // isIntersecting's value will be true\n                if (entry.isIntersecting) {\n                    // using a dynamic import to 'lazy load' the component\n                    import(`../${pathComponent}`)\n                        .then(async res => {\n                            const ComponentLazyLoaded = res.default\n                            await setComponentToLoad(\n                                <FadeInComponent fadeInEffect={fadeInEffect}>\n                                    <ComponentLazyLoaded />\n                                </FadeInComponent>\n                            )\n                            if(debugMode === \"true\") {\n                                let splitPathComponentToLoad = pathComponent.split('/')\n                                console.log(`Loaded ==> ${splitPathComponentToLoad[splitPathComponentToLoad.length - 1]}`)\n                            }\n                        })\n                    // disable the observer (further checks aren't necessary)\n                    observer.disconnect()\n                }\n            })\n        })\n        // starting with observe the element with id = idElementActivation\n        io.observe(target)\n    }\n\n    const initComponent = _ => {\n        // identify the HTML element with id = idElementActivation\n        let targetElement = document.getElementById(idElementActivation)\n        lazyLoading(targetElement)\n    }\n\n    useEffect(_ => {\n        // activate the IntersectionObserver\n        initComponent()\n    }, [])\n\n    return (\n        // 'lazy-load-component' class has (padding: 50px 0;). DO NOT REMOVE IT :)\n        <div className=\"lazy-load-component\">\n            {ComponentToLoad}\n            {/* the div with id-absolute-div class has the id that will trigger the IntersetionObserver of the next LazyLoadingComponent */}\n            <div className=\"id-absolute-div\" id={idElementForNextLazyLoading}></div>\n        </div>\n    )\n}\n\nexport default LazyLoadingComponent","import React from 'react'\nimport LazyLoadingComponent from '../LazyLoadingComponent/LazyLoadingComponent'\nimport Component1 from '../TestComponents/Component1/Component1'\nimport './App.css'\n\nconst App = _ => {\n  return (\n    <div className=\"App\">\n      <Component1 />\n      <LazyLoadingComponent\n        idElementActivation=\"component1\"\n        idElementForNextLazyLoading=\"lazy-load-1\"\n        pathComponent=\"TestComponents/Component2/Component2\"\n        fadeInEffect=\"fadeInLeft\"\n        debugMode=\"true\"\n      />\n      <LazyLoadingComponent\n        idElementActivation=\"lazy-load-1\"\n        idElementForNextLazyLoading=\"lazy-load-2\"\n        pathComponent=\"TestComponents/Component3/Component3\"\n        fadeInEffect=\"fadeInRight\"\n        debugMode=\"true\"\n      />\n      <LazyLoadingComponent\n        idElementActivation=\"lazy-load-2\"\n        idElementForNextLazyLoading=\"lazy-load-3\"\n        pathComponent=\"TestComponents/Component4/Component4\"\n        fadeInEffect=\"fadeInLeft\"\n        debugMode=\"true\"\n      />\n      <LazyLoadingComponent\n        idElementActivation=\"lazy-load-3\"\n        idElementForNextLazyLoading=\"lazy-load-4\"\n        pathComponent=\"TestComponents/Component5/Component5\"\n        fadeInEffect=\"fadeInRight\"\n        debugMode=\"true\"\n      />\n      <LazyLoadingComponent\n        idElementActivation=\"lazy-load-4\"\n        idElementForNextLazyLoading=\"lazy-load-5\"\n        pathComponent=\"TestComponents/Component6/Component6\"\n        fadeInEffect=\"fadeInLeft\"\n        debugMode=\"true\"\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react'\n\n// FadeInComponent return its children inside a div which shows an animation from animate.css passed as props.\n// If fadeInEffect has value of undefined, only the children will be returned\nconst FadeInComponent = ({ fadeInEffect = \"undefined\", children }) => {\n    const returnHTMLCode = _ => (\n        // if no fadeInEffect was passed as argument, then only the children will be returned,\n        // otherwise a div (containing the children) with a fadeInEffect class will be returned\n        (fadeInEffect !== \"undefined\" && fadeInEffect !== null && fadeInEffect !== '') ? (\n            // 'animated' class is necessary for using animate.css class effects\n            <div className={`animated ${fadeInEffect}`}>\n                { children }\n            </div>\n        ) : (\n            <>\n                { children }\n            </>\n        )\n    )\n\n    return( returnHTMLCode() )\n}\n\nexport default FadeInComponent","import React from 'react'\n\nexport default _ => (\n    <div id=\"component1\" className=\"component no-lazy-load-component\">\n        This is component 1\n    </div>\n)","var map = {\n\t\"./App/App\": [\n\t\t2,\n\t\t9\n\t],\n\t\"./App/App.css\": [\n\t\t8,\n\t\t7\n\t],\n\t\"./App/App.jsx\": [\n\t\t2,\n\t\t9\n\t],\n\t\"./LazyLoadingComponent/FadeInComponent\": [\n\t\t3,\n\t\t9\n\t],\n\t\"./LazyLoadingComponent/FadeInComponent.jsx\": [\n\t\t3,\n\t\t9\n\t],\n\t\"./LazyLoadingComponent/LazyLoadingComponent\": [\n\t\t1,\n\t\t9\n\t],\n\t\"./LazyLoadingComponent/LazyLoadingComponent.css\": [\n\t\t7,\n\t\t7\n\t],\n\t\"./LazyLoadingComponent/LazyLoadingComponent.jsx\": [\n\t\t1,\n\t\t9\n\t],\n\t\"./TestComponents/Component1/Component1\": [\n\t\t4,\n\t\t9\n\t],\n\t\"./TestComponents/Component1/Component1.jsx\": [\n\t\t4,\n\t\t9\n\t],\n\t\"./TestComponents/Component2/Component2\": [\n\t\t12,\n\t\t9,\n\t\t0\n\t],\n\t\"./TestComponents/Component2/Component2.jsx\": [\n\t\t12,\n\t\t9,\n\t\t0\n\t],\n\t\"./TestComponents/Component3/Component3\": [\n\t\t13,\n\t\t9,\n\t\t1\n\t],\n\t\"./TestComponents/Component3/Component3.jsx\": [\n\t\t13,\n\t\t9,\n\t\t1\n\t],\n\t\"./TestComponents/Component4/Component4\": [\n\t\t14,\n\t\t9,\n\t\t2\n\t],\n\t\"./TestComponents/Component4/Component4.jsx\": [\n\t\t14,\n\t\t9,\n\t\t2\n\t],\n\t\"./TestComponents/Component5/Component5\": [\n\t\t15,\n\t\t9,\n\t\t3\n\t],\n\t\"./TestComponents/Component5/Component5.jsx\": [\n\t\t15,\n\t\t9,\n\t\t3\n\t],\n\t\"./TestComponents/Component6/Component6\": [\n\t\t16,\n\t\t9,\n\t\t4\n\t],\n\t\"./TestComponents/Component6/Component6.jsx\": [\n\t\t16,\n\t\t9,\n\t\t4\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(2).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, ids[1])\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 23;\nmodule.exports = webpackAsyncContext;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './components/App/App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}